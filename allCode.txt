function bubbleSort(i, j, curRoundConfig) {
    if (curRoundConfig.canciled) {
        handleNewState(GENERATED_STATE)
        return
    }

    temp = function () {
        if (j >= array.length - i - 1) {
            j = 0
            setElementStateToSortedBS(array.length - 1 - i)
            i++
        }
        if (i >= array.length - 1) {
            setElementStateToSortedBS(0)
            handleNewState(GENERATED_STATE)
            return
        }

        setElementStateToComparingBS(j)
        setElementStateToComparingBS(j + 1)

        setTimeout(function () {
            temp = function () {
                if (curRoundConfig.canciled) {
                    handleNewState(GENERATED_STATE)
                    return
                }
                if (array[j] > array[j + 1]) {
                    swap(j, j + 1)
                }

                setTimeout(function () {
                    temp = function () {
                        setElementStateToNormalBS(j)
                        setElementStateToNormalBS(j + 1)
                        bubbleSort(i, j + 1, curRoundConfig)
                    }
                    if (curRoundConfig.stopped) {
                        curRoundConfig.noticeFunction = temp
                    } else {
                        temp()
                    }
                }, sortDelay)
            }
            if (curRoundConfig.stopped) {
                curRoundConfig.noticeFunction = temp
            } else {
                temp()
            }
        }, sortDelay)
    }
    if (curRoundConfig.stopped) {
        curRoundConfig.noticeFunction = temp
    } else {
        temp()
    }
    /*
    for(let i = 0;i < array.length;i++) {
        for(let j = 0;j < array.length - i - 1;j++) {
            if(array[j] < array[j + 1]) {
                let c = array[j]
                array[j] = array[j + 1]
                array[j + 1] = c
            }
        }
    }
    */
}

function setElementStateToComparingBS(index) {
    changeElement(index, "white", "black")
}

function setElementStateToNormalBS(index) {
    changeElement(index, "black", "white")
}

function setElementStateToSortedBS(index) {
    changeElement(index, "red", "white")
}

function bubbleSortStarter(config) {
    bubbleSort(0, 0, config)
    const selectionSortUnits = [];
    selectionSortUnits.push(getExplanationUnit("Элемент", "black", "white"))
    selectionSortUnits.push(getExplanationUnit("Сравниваемый элемент", "white", "black"))
    selectionSortUnits.push(getExplanationUnit("Отсортированный элемент", "red", "white"))
    return selectionSortUnits
}

$(function () {
    addSort("Сортировка пузырьком", bubbleSortStarter)
})
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Визуализатор сортировак</title>
    <script src="jQuery.js"></script>

    <script src="sortUtils.js"></script>
    <script src="bubbleSort.js"></script>
    <script src="selectionSort.js"></script>
    <script src="script.js"></script>

    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="main-wrap">
        <div class="wrap">

            <div class="menu">
                <select class="sort-selector">
                </select>

                <select class="generator-selector">
                    <option selected>Случайная</option>
                    <option>Синус</option>
                    <option>Линия</option>
                </select>

                <button class="start-button">Начать</button>
                <button class="generate-button">Сгенерировать</button>
                <button class="terminate-button">Остановить</button>

                <label class="sort-delay-select-area">
                    <span>Задержка при визуализации(в мс) :</span>
                    <input class="sort-delay-input" type="text" maxlength="4" onkeypress="return isNumberKey(event)">
                </label>

                <label class="element-count-setter">
                    <span>Количество элементов :</span>
                    <input class="element-count-input" type="text" maxlength="2" onkeypress="return isNumberKey(event)">
                </label>

                <label class="max-element-setter">
                    <span>Верхняя граница среди элементов :</span>
                    <input class="max-element-input" type="text" maxlength="4" onkeypress="return isNumberKey(event)">
                </label>
            </div>
            <div class="working-area">
                <div class="elements">

                </div>
            </div>
            <div class="message-area">
                <div class="message"></div>
            </div>
        </div>
        <div class="explanation">
        </div>
    </div>
</body>

</html>
let currentRoundConfig = {
    elementCount: 10,
    maxElement: 10,
    canciled: false,
    stopped: false,
    noticeFunction: null
}

const inputs = {
    sortSelector: null,
    sortDelaySelect: null,
    elementCountInput: null,
    maxElementInput: null,
    startButton: null,
    terminateButton: null,
    generatorSelector: null
}

let array = []
let transformArray = [] // not in pixels, but in elements
let referenceArray = []
let elementsDiv = null
const SORTING_STATE = 0
const STOP_STATE = 1
const GENERATED_STATE = 2
let state = NOT_GENERATED_STATE = 3
let sortDelay = 500

function genArray(generator) {
    array = []
    for (let i = 0; i < currentRoundConfig.elementCount; i++) {
        array[i] = Math.floor(generator(currentRoundConfig.elementCount, i) * currentRoundConfig.maxElement)
        transformArray[i] = 0
        referenceArray[i] = i
    }
}

function calcElementWidth() { // in %
    return Math.min(3.0, 100.0 / currentRoundConfig.elementCount)
}

function calcElementMargin() {
    return calcElementWidth() / 10
}

function createElementsFromArray() {
    let elementWidth = calcElementWidth()
    let elementMargin = calcElementMargin()
    elementsDiv.empty()
    for (let i = 0; i < array.length; i++) {
        let elementHeight = (array[i] * 1.0 / currentRoundConfig.maxElement) * 100
        elementsDiv.append(`<div class=\"element\" style=\"width: ${elementWidth}%; height: ${elementHeight}%; margin-right:${elementMargin}\"></div>`)
        elementsDiv.last().css("margin-right", "0")
    }
}

function isNumberKey(evt) {
    var charCode = (evt.which) ? evt.which : evt.keyCode
    if (charCode > 31 && (charCode < 48 || charCode > 57))
        return false
    return true
}

let messageClearFuncId
let messageElement = null
function message(mes) {
    messageElement.text(mes)
    clearTimeout(messageClearFuncId)
    messageClearFuncId = setTimeout(function () {
        messageElement.text("")
    }, 2000)
}


function setup() {
    elementsDiv = $(".elements")
    inputs.sortSelector = $(".sort-selector")
    inputs.sortDelaySelect = $(".sort-delay-input")
    inputs.elementCountInput = $(".element-count-input")
    inputs.maxElementInput = $(".max-element-input")
    inputs.startButton = $(".start-button")
    inputs.terminateButton = $(".terminate-button")
    inputs.generatorSelector = $(".generator-selector")

    inputs.sortDelaySelect.val(sortDelay)
    inputs.elementCountInput.val(currentRoundConfig.elementCount)
    inputs.maxElementInput.val(currentRoundConfig.maxElement)

    inputs.sortDelaySelect.on("change", function () {
        let newDelay = inputs.sortDelaySelect.val()
        if (!(newDelay !== undefined && newDelay > 0 && newDelay < 10000)) return
        sortDelay = Math.max(20, newDelay)
        $(".element").css("transition", `all ${sortDelay * 0.8}ms ease`)
    })

    inputs.terminateButton.on("click", function () {
        if (state === SORTING_STATE) {
            currentRoundConfig.canciled = true
            handleNewState(GENERATED_STATE)

            let newConfig = {}

            newConfig.elementCount = currentRoundConfig.elementCount
            newConfig.maxElement = currentRoundConfig.maxElement
            newConfig.canciled = false
            newConfig.stopped = false
            newConfig.noticeFunction = null
            currentRoundConfig = newConfig
            setAllElementsStateToNormal()
        }
    })

    messageElement = $(".message")
}

function handleNewState(newState) {
    state = newState
    switch (state) {
        case GENERATED_STATE:
            inputs.startButton.text("Начать")
            break
        case STOP_STATE:
            inputs.startButton.text("Продолжить")
            break
        case SORTING_STATE:
            inputs.startButton.text("Пауза")
            break
        case NOT_GENERATED_STATE:
            inputs.startButton.text("Начать")
            break
    }
}

function getSortByName(name) {
    for (let sort in sorts) {
        if (sorts[sort].name === name) {
            return sorts[sort].starter
        }
    }
}

function isConfigCorrect(currentRoundConfig) {
    let result = {
        result: false,
        comment: ""
    }
    if (currentRoundConfig.elementCount !== undefined) {
        if (currentRoundConfig.maxElement !== undefined) {
            if (isNumberKey(currentRoundConfig.elementCount)) {
                if (isNumberKey(currentRoundConfig.maxElement)) {
                    if (currentRoundConfig.elementCount < 100) {
                        if (currentRoundConfig.maxElement < 10000) {
                            if (currentRoundConfig.elementCount > 1) {
                                if (currentRoundConfig.maxElement > 1) {
                                    result.result = true
                                } else {
                                    result.comment = "Верхняя граница элементов должна быть больше 1"
                                }
                            } else {
                                result.comment = "Количество элементов должно быть больше 1"
                            }
                        } else {
                            result.comment = "Верхняя граница элементов должна быть меньше 10000"
                        }
                    } else {
                        result.comment = "количество элементов должно быть меньше 100"
                    }
                } else {
                    result.comment = "верхняя граница элементов должна быть натуральным числом"
                }
            } else {
                result.comment = "Количество элементов должно быть натуральным числом"
            }
        } else {
            result.comment = "Верхняя граница элементов не определена"
        }
    } else {
        result.comment = "Количество элементов не определено"
    }
    return result
}

function randomGenerator(count, i) { return Math.random() }

function sineGenerator(count, i) { return Math.sin(i * 1.0 / count * 2 * Math.PI) / 2.0 + 0.5 }

function lineGenerator(count, i) { return (count - i) * 1.0 / count }

function getGeneratorFromName(name) {
    switch (name) {
        case "Случайная": return randomGenerator
        case "Синус": return sineGenerator
        case "Линия": return lineGenerator
    }
}

$(function () {
    setup();
    $(".generate-button").on("click", function () {
        let newConfig = {}

        newConfig.elementCount = inputs.elementCountInput.val()
        newConfig.maxElement = inputs.maxElementInput.val()
        newConfig.canciled = false
        newConfig.stopped = false
        newConfig.noticeFunction = null
        let configCheckResult = isConfigCorrect(newConfig)
        if (configCheckResult.result) {
            currentRoundConfig.canciled = true
            currentRoundConfig = newConfig
            let generator = getGeneratorFromName(inputs.generatorSelector.val())
            if (generator !== undefined) {
                genArray(generator)
                createElementsFromArray()
                $(".element").css("transition", `all ${sortDelay * 0.8}ms ease`)
                handleNewState(GENERATED_STATE)
            } else {
                message("Имя генератора неправильное")
            }
        } else {
            message(configCheckResult.comment)
        }
    })
    $(".start-button").on("click", function () {
        if (state === STOP_STATE) {
            currentRoundConfig.stopped = false
            handleNewState(SORTING_STATE)
            currentRoundConfig.noticeFunction()
        } else if (state === SORTING_STATE) {
            currentRoundConfig.stopped = true
            handleNewState(STOP_STATE)
        } else if (state === GENERATED_STATE) {
            let sortName = inputs.sortSelector.val()
            let sort = getSortByName(sortName)
            if (sort !== undefined) {
                setAllElementsStateToNormal()
                handleNewState(SORTING_STATE)
                const expUnits = sort(currentRoundConfig)
                const explanation = $(".explanation")
                explanation.empty()
                expUnits.forEach(element => {
                    explanation.append(element)
                });
            } else {
                message("Имя сортировки неправильное")
            }
        } else {
            message("Сгенерируйте ваш массив")
        }
    })
})
/*
localisations
*/
function selectionSort(minPos, i, j, config) {
    if (config.canciled) {
        handleNewState(GENERATED_STATE)
        return
    }
    temp = function () {
        temp = function () {
            if (config.canciled) {
                handleNewState(GENERATED_STATE)
                return
            }
            temp = function () {
                if (i >= array.length || j >= array.length) {
                    setElementStateToSortedSS(array.length - 1)
                    handleNewState(GENERATED_STATE)
                    return
                }
                setElementStateToComparingSS(j)
                setTimeout(function () {
                    if (config.canciled) {
                        handleNewState(GENERATED_STATE)
                        return
                    }
                    temp = function () {
                        setElementStateToNormalSS(j)
                        setElementStateToNormalSS(minPos)
                        if (array[j] < array[minPos]) {
                            minPos = j
                        }
                        setElementStateToMinElementSS(minPos)
                        setTimeout(function () {
                            if (config.canciled) {
                                handleNewState(GENERATED_STATE)
                                return
                            }
                            temp = function () { selectionSort(minPos, i, j + 1, config) }
                            if (config.stopped) noticeFunction = temp
                            else temp()
                        }, sortDelay)
                    }
                    if (config.stopped) noticeFunction = temp
                    else temp()
                }, sortDelay)
            }
            if (config.stopped) config.noticeFunction = temp
            else temp()
        }

        temp2 = function () { }
        needTimeout = false
        if (j >= array.length) {
            swap(minPos, i)
            setElementStateToSortedSS(i)
            temp2 = function () {
                i++
                j = i + 1
                minPos = i
                setElementStateToMinElementSS(minPos)
            }
            needTimeout = true
        }
        if (needTimeout) {
            setTimeout(function () {
                if (config.canciled) {
                    handleNewState(GENERATED_STATE)
                    return
                }
                temp3 = function () {
                    temp2()
                    setTimeout(temp, sortDelay)
                }
                if (config.stopped) config.noticeFunction = temp3
                else temp3()
            }, sortDelay)
        } else {
            setTimeout(temp, sortDelay)
        }
    }
    if (config.stopped) config.noticeFunction = temp
    else temp()

    /*
    let minPos
    for (let i = 0; i < array.length; i++) {
        minPos = i
        for (let j = i + 1; j < array.length; j++) {
            if (array[j] < array[minPos]) minPos = j;
        }
        let c = array[minPos]
        array[minPos] = array[i]
        array[i] = c
    }*/
}

function setElementStateToComparingSS(index) {
    changeElement(index, "white", "black")
}

function setElementStateToNormalSS(index) {
    changeElement(index, "black", "white")
}

function setElementStateToSortedSS(index) {
    changeElement(index, "red", "white")
}

function setElementStateToMinElementSS(index) {
    changeElement(index, "yellow", "white")
}

function selectionSortStarter(config) {
    selectionSort(0, 0, 0, config)
    const selectionSortUnits = [];
    selectionSortUnits.push(getExplanationUnit("Элемент", "black", "white"))
    selectionSortUnits.push(getExplanationUnit("Сравниваемый элемент", "white", "black"))
    selectionSortUnits.push(getExplanationUnit("Отсортированный элемент", "red", "white"))
    selectionSortUnits.push(getExplanationUnit("Минимальный элемент в неотсортированном массиве", "yellow", "white"))
    return selectionSortUnits
}

$(function () {
    addSort("Сортировка выбором", selectionSortStarter)
})
const sorts = []

function addSort(name, starter) {
    const newSort = {
        name,
        starter
    }
    sorts.push(newSort)
    const sortSelector = $(".sort-selector")
    sortSelector.empty()
    for (let i = 0; i < sorts.length; i++) {
        sortSelector.append(`<option${i === 0 ? " selected" : ""}>${sorts[i].name}</option>`)
    }
}

function getExplanationUnit(text, bgColor, borderColor) {
    return "<div class=\"explanation-unit\">" +
        "<span class=\"explanation-element-wrap\">" +
        `<div class=\"explanation-element-example\" style=\"background-color:${bgColor}; border-color:${borderColor};\"></div>` +
        `<span class=\"explanation-unit-text\"> - ${text}</span>` +
        "</span>" +
        "</div>"
}

function changeElement(index, bgColor, borderColor) {
    let element = getElement(index)
    element.css("background-color", bgColor)
    element.css("border-color", borderColor)
}

function getElement(index) {
    return $(`.element:nth-child(${referenceArray[index] + 1})`)
}

function setElementHeight(index, height) {
    getElement(index).css("height", `${height * 100.0 / currentRoundConfig.maxElement}%`)
}

function setAllElementsStateToNormal() {
    let e = $(".element")
    e.css("background-color", "black")
    e.css("border-color", "white")
}

function swap(index1, index2) {
    let difference = referenceArray[index2] - referenceArray[index1]
    transformArray[index1] += difference
    transformArray[index2] -= difference
    let c = array[index1]
    array[index1] = array[index2]
    array[index2] = c
    c = referenceArray[index1]
    referenceArray[index1] = referenceArray[index2]
    referenceArray[index2] = c
    getElement(index1).css("left", `${-transformArray[index1] / array.length * 100}%`)
    getElement(index2).css("left", `${-transformArray[index2] / array.length * 100}%`)
}
/*
#051e3e
#251e3e
#451e3e
#651e3e
#851e3e
*/

html {
    height: 100%;
    font-family: sans-serif;
}

body {
    margin: 0;
    padding: 0;
    background-color: #71d137;
    font-size: 1.5em;
    color: white;
    height: 100%;
}

.main-wrap {
    height: 100%;
    display: grid;
    grid-template-columns: 1fr 12em;
}

.wrap {
    height: 100%;
    display: grid;
    grid-template-rows: min-content 1fr min-content;
}

.menu {
    display: flex;
    flex-direction: row;
    justify-content: space-around;
    padding: 20px;
    position: relative;
    flex-wrap: wrap;
}

.menu label span {
    user-select: none;
}

.explanation {
    padding: 0.5em;
    border-left: 3px solid #2e6110;
}

.explanation-element-example {
    width: 1em;
    height: 1em;
    border-radius: 50%;
    display: inline-block;
    vertical-align: middle;
    border: 1px solid;
}

.normal-element {
    border: 1px solid white;
    background-color: black;
}

.comparing-element {
    border: 1px solid black;
    background-color: white;
}

.sorted-element {
    border: 1px solid white;
    background-color: red;
}

.min-element {
    border: 1px solid white;
    background-color: yellow;
}

.explanation-unit-text {
    word-break: break-word;
}

.explanation-unit {
    width: 100%;
    margin-bottom: 1em;
}

.main-explanation {
    width: 100%;
}

input,
select,
button {
    outline: none;
    background-color: #3e7120;
    border: 2px solid black;
    border-radius: 10px;
    color: white;
    transition: all 0.2s;
    margin: 0.1em;
    user-select: none;
}

input:hover,
select:hover,
button:hover,
input:focus,
select:focus,
button:focus {
    background-color: #2e6110;
}

input {
    font-size: inherit;
    width: 2.25em;
}

select {
    font-size: inherit;
}

button {
    font-size: inherit;
    min-width: 4.5em;
}

.working-area {
    display: flex;
    justify-content: center;
    align-items: center;
    border-top: 3px solid #2e6110;
}

.elements {
    height: 90%;
    width: 90%;
    display: flex;
    flex-direction: row;
    justify-content: space-around;
    align-items: flex-end;
    padding: 10px;
    border: 5px solid white;
    border-radius: 10px;
    position: relative;
}

.element {
    background-color: black;
    border-radius: 100px;
    border: 1px solid white;
    min-width: 1px;
    position: relative;
    left: 0;
}

.message-area {
    margin: auto;
    width: 90%;
    padding: 0.3em;
}

.message {
    word-break: break-word;
    width: 100%;
    margin: auto;
    text-align: center;
}
